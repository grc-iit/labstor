<h1>LabStor: LabStor: A Modular and Extensible Platform for Developing High-Performance, Customized I/O Stacks in Userspace</h1>

<section>
  <h2>Summary</h2>

  <p>
    LabStor is a development platform, which aims to compete with the
    performance of in-kernel filesystems while also leveraging the development
    benefits of userspace. LabStor promotes the Single Responsibility Principle,
    where code reusability, scalability, and speedy development is achieved by
    loosely coupled components, organized in smaller code bases
  </p>


  <p>LabStor provides three tools</p>
  <ul>
    <li>
      <h3>LabMod</h3>
      <p>
        An independent, self-contained code object implementing a well-defined,
        distinct, single-purpose functionality.
      </p>
    </li>

    <li>
      <h3>LabStack</h3>
      <p>
        A user-defined combination of compatible LabMods into a single I/O system.
      </p>
    </li>

    <li>
      <h3>LabRuntime</h3>
      <p>
        The primary warehouse and execution engine of LabStacks.
      </p>
    </li>
  </ul>
</section>

<section>
  <h2>Compiling LabStor</h2>

  <p>LabStor is currently only supported on Linux.</p>

  <p>

  </p>
</section>

<section>
  <h2>Basic Usage</h2>

  <ol>
    <li>
      <p>First, insert the Kernel Operations Manager kernel module.</p>
      <p>

      </p>
    </li>

    <li>
      Second, launch the LabStor Runtime binary.
    </li>

    <li>
      Third,
    </li>
  </ol>

</section>

<section>
  <h2>The LabMod</h2>

  <p>
    LabMods are independent, self-contained code objects implementing a well-defined,
    distinct, single-purpose functionality.
  </p>

  <p>LabMods are comprised of four components</p>
  <ul>
    <li>
      <h3>Type</h3>
      <p>
        The set of APIs the LabMod implements.
      </p>
    </li>
    <li>
      <h3>Operation</h3>
      <p>
        Performs a single task, which takes a well-defined input and produces a
        well-defined output.
      </p>
    </li>
    <li>
      <h3>State<h3>
      <p>
        Any data required by the operation in order to complete.
      </p>
    </li>
    <li>
      <h3>Connector</h3>
      <p>
        The code object used by modules and applications to call the operation.
      </p>
    </li>
  </ul>
</section>

<section>
  <h2>Provided LabMods</h2>

  <ul>
    <li>
      <h3>Driver LabMods</h3>
      <ul>
        <li>Linux Block Device</li>
        <li>Linux Multi-Queue Device</li>
        <li>NVMe Block Device</li>
        <li>NVMe Zoned Namespace</li>
        <li>PMEM DAX Block Device</li>
      </ul>
    </li>

    <li>
      <h3>I/O Scheduler</h3>
      <ul>
        <li>No-Op</li>
        <li>Blk-Switch</li>
      </ul>
    </li>
  </ul>
</section>

<section>
  <h2>The LabStack</h2>

  <p>
    The LabStack is a user-defined combination of LabMods into a single
    I/O system. One powerful property of LabStacks is the ability to
    share LabMods.
  </p>
</section>

<section>
  <h2>The LabStor Runtime</h2>

  <p>
    The LabStor Runtime is the primary warehouse and execution engine
    of LabStor. It is responsible for managing updates to LabMods,
    locating LabStacks, and executing LabStacks.
  </p>

  <p>The primary components of the Runtime are as follows</p>
</section>


<section>
  <h2>LabStack & LabMod Upgrades</h2>

  <p>
    In order to provide high-velocity testing, LabStor supports dynamic
    upgrades to LabMods and LabStacks dynamically through two protocols:
    the centralized upgrade and decentralized upgrade protocol.
  </p>

  <p>In general, LabStor supports two types of upgrades:</p>
  <ul>
    <li>Changing the code of a LabMod</li>
    <li>Changing the state of a LabMod</li>
  </ul>

  <p>
    By changing the code of a LabMod, new patches can be applied dynamically
    while applications are still running.
  </p>

  <p>
    By changing the state of a LabMod, one can dynamically change policies.
  </p>
</section>

<section>
  <h3>The LabStor Client Library</h3>

  <p>
    The LabStor Client Library is responsible for creating a thing.
  </p>
</section>
